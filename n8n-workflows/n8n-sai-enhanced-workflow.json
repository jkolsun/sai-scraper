{
  "name": "SAI Scraper - Enhanced Lead Intelligence",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "sai-google-ads",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [100, 500],
      "webhookId": "sai-google-ads"
    },
    {
      "parameters": {
        "jsCode": "// Normalize Inputs\n// Extracts and normalizes domains, sets up processing options\nconst body = $input.first().json.body || {};\nconst domains = body.domains || [];\nconst options = body.options || {};\n\n// Default options\nconst config = {\n  includeLinkedIn: options.includeLinkedIn !== false,\n  includeIndeed: options.includeIndeed !== false,\n  includeInstagram: options.includeInstagram || false,\n  includeTikTok: options.includeTikTok || false,\n  skipCache: options.skipCache || false,\n  maxAge: options.maxAge || 86400000 // 24 hours in ms\n};\n\n// Return each domain as separate item for processing\nreturn domains.map(domain => {\n  // Clean domain\n  let cleanDomain = domain\n    .replace(/^https?:\\/\\//, '')\n    .replace(/^www\\./, '')\n    .split('/')[0]\n    .toLowerCase()\n    .trim();\n  \n  return {\n    json: {\n      domain: cleanDomain,\n      originalDomain: domain,\n      config,\n      timestamp: Date.now(),\n      signals: {},\n      scores: {},\n      errors: []\n    }\n  };\n});"
      },
      "id": "normalize-inputs",
      "name": "Normalize Inputs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [300, 500]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {
          "delayBetweenBatches": 1500
        }
      },
      "id": "loop-domains",
      "name": "Loop Domains",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [500, 500]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "cache-check",
              "leftValue": "={{ $json.config.skipCache }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals"
              }
            }
          ]
        }
      },
      "id": "check-cache",
      "name": "Cache Fresh?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [700, 500],
      "notes": "Check if we have fresh cached data for this domain"
    },
    {
      "parameters": {
        "url": "=https://www.google.com/search?q=site:{{$json.domain}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "serp-discovery",
      "name": "SERP Discovery",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 400],
      "continueOnFail": true,
      "notes": "Discover domain info via Google search"
    },
    {
      "parameters": {
        "jsCode": "// Extract domain info from SERP results\nconst item = $input.first().json;\nconst html = item.data || '';\n\n// Extract any additional domain info from SERP\nlet domainVerified = html.includes(item.domain);\nlet serpSnippet = '';\n\n// Try to extract meta description or snippet\nconst snippetMatch = html.match(/<span class=\"[^\"]*\"[^>]*>([^<]{50,200})<\\/span>/i);\nif (snippetMatch) {\n  serpSnippet = snippetMatch[1];\n}\n\nreturn [{\n  json: {\n    ...item,\n    domainVerified,\n    serpSnippet,\n    serpChecked: true\n  }\n}];"
      },
      "id": "extract-serp",
      "name": "Extract Domain from SERP",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 400]
    },
    {
      "parameters": {
        "url": "=https://www.google.com/search?q={{$json.domain}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "fetch-serp-ads",
      "name": "Fetch SERP for Ads",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1300, 400],
      "continueOnFail": true,
      "notes": "Check Google search results for ads"
    },
    {
      "parameters": {
        "jsCode": "// Parse Ads Presence from SERP\nconst item = $input.first().json;\nconst html = item.data || '';\n\n// Detect sponsored/ad indicators in SERP\nconst adIndicators = [\n  /class=\"[^\"]*ad[^\"]*\"/gi,\n  /Sponsored/gi,\n  /Ad·/gi,\n  /<div[^>]*data-text-ad/gi\n];\n\nlet adsDetected = false;\nlet adCount = 0;\n\nfor (const pattern of adIndicators) {\n  const matches = html.match(pattern);\n  if (matches) {\n    adsDetected = true;\n    adCount += matches.length;\n  }\n}\n\nreturn [{\n  json: {\n    ...item,\n    signals: {\n      ...item.signals,\n      googleAds: {\n        detected: adsDetected,\n        adCount: Math.min(adCount, 10),\n        confidence: adsDetected ? 75 : 0,\n        source: 'serp'\n      }\n    }\n  }\n}];"
      },
      "id": "parse-ads",
      "name": "Parse Ads Presence",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1500, 400]
    },
    {
      "parameters": {
        "url": "=https://adstransparency.google.com/anji/_/rpc/SearchService/SearchCreatives",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/x-www-form-urlencoded"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
          ]
        },
        "sendBody": true,
        "contentType": "form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "f.req",
              "value": "={{JSON.stringify([[null,null,null,null,null,null,null,[$json.domain]]]})}}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "check-ads-transparency",
      "name": "Check Ads Transparency API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1700, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Process Google Ads Transparency API response\nconst item = $input.first().json;\nlet adsFromApi = false;\nlet apiConfidence = 0;\nlet adDetails = null;\n\ntry {\n  const response = item.data || '';\n  const data = typeof response === 'string' ? response : JSON.stringify(response);\n  \n  if (data.includes('creative') || data.includes('advertiser') || data.length > 100) {\n    adsFromApi = true;\n    apiConfidence = 85;\n    adDetails = 'Active ads found in Google Ads Transparency Center';\n  }\n} catch (e) {\n  // API check failed, rely on SERP\n}\n\n// Merge with existing signals\nconst existingAds = item.signals?.googleAds || {};\nconst finalDetected = adsFromApi || existingAds.detected;\nconst finalConfidence = Math.max(apiConfidence, existingAds.confidence || 0);\n\nreturn [{\n  json: {\n    ...item,\n    signals: {\n      ...item.signals,\n      googleAds: {\n        detected: finalDetected,\n        confidence: finalConfidence,\n        details: adDetails || (existingAds.detected ? 'Ads detected in search results' : null),\n        source: adsFromApi ? 'transparency_api' : 'serp',\n        adCount: existingAds.adCount || 0\n      }\n    }\n  }\n}];"
      },
      "id": "store-ads-result",
      "name": "Store Ads Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1900, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "ads-check",
              "leftValue": "={{ $json.signals.googleAds.detected }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "ads-present-check",
      "name": "Ads Present?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2100, 400],
      "notes": "Only continue scraping if ads are detected"
    },
    {
      "parameters": {
        "jsCode": "// BLOCK - Company disqualified (no ads = not actively spending)\nconst item = $input.first().json;\n\nreturn [{\n  json: {\n    ...item,\n    disqualified: true,\n    disqualifyReason: 'No active Google Ads detected - company not actively spending on paid traffic',\n    score: 0,\n    confidence: 0\n  }\n}];"
      },
      "id": "block-disqualified",
      "name": "BLOCK (Disqualified)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2300, 600],
      "notes": "Company doesn't have ads - disqualify"
    },
    {
      "parameters": {
        "url": "=https://{{$json.domain}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            }
          ]
        },
        "options": {
          "timeout": 15000,
          "redirect": {
            "redirect": {
              "followRedirects": true,
              "maxRedirects": 5
            }
          }
        }
      },
      "id": "scrape-website",
      "name": "Scrape Website",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2300, 300],
      "continueOnFail": true,
      "notes": "Fetch website HTML for signal extraction"
    },
    {
      "parameters": {
        "jsCode": "// Extract Business Hours from website\nconst item = $input.first().json;\nconst html = (item.data || '').toLowerCase();\n\n// Patterns for business hours\nconst hoursPatterns = [\n  /hours?[:\\s]*(\\d{1,2}[:\\s]?(?:am|pm)?\\s*[-–to]+\\s*\\d{1,2}[:\\s]?(?:am|pm)?)/gi,\n  /open[:\\s]*(\\d{1,2}[:\\s]?(?:am|pm)?\\s*[-–to]+\\s*\\d{1,2}[:\\s]?(?:am|pm)?)/gi,\n  /monday\\s*[-–]\\s*friday/gi,\n  /mon\\s*[-–]\\s*fri/gi,\n  /24\\/7|24 hours|always open/gi,\n  /business hours/gi\n];\n\nlet hoursFound = [];\nlet has24x7 = false;\nlet hasWeekendHours = false;\n\nfor (const pattern of hoursPatterns) {\n  const matches = html.match(pattern);\n  if (matches) {\n    hoursFound = hoursFound.concat(matches);\n    if (/24\\/7|24 hours|always/i.test(matches.join(' '))) {\n      has24x7 = true;\n    }\n    if (/saturday|sunday|weekend/i.test(matches.join(' '))) {\n      hasWeekendHours = true;\n    }\n  }\n}\n\nreturn [{\n  json: {\n    ...item,\n    htmlContent: item.data,\n    hoursData: {\n      hoursFound: hoursFound.slice(0, 5),\n      has24x7,\n      hasWeekendHours,\n      hoursDetected: hoursFound.length > 0\n    }\n  }\n}];"
      },
      "id": "extract-hours",
      "name": "Extract Business Hours",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2500, 300]
    },
    {
      "parameters": {
        "jsCode": "// Detect After-Hours Response capability\nconst item = $input.first().json;\nconst html = (item.htmlContent || '').toLowerCase();\n\n// Chat widget patterns (indicates potential after-hours coverage)\nconst chatWidgets = {\n  drift: /drift\\.com|dc\\.js|driftt/i,\n  intercom: /intercom\\.com|intercom\\.io|widget\\.intercom/i,\n  zendesk: /zendesk\\.com|zopim|zdassets/i,\n  hubspot: /hubspot\\.com\\/conversations|hs-scripts/i,\n  freshdesk: /freshdesk\\.com|freshchat/i,\n  crisp: /crisp\\.chat|crisp\\.im/i,\n  livechat: /livechatinc\\.com|livechat/i,\n  olark: /olark\\.com/i,\n  tawk: /tawk\\.to/i\n};\n\nlet chatWidgetDetected = null;\nlet chatWidgetCount = 0;\n\nfor (const [name, pattern] of Object.entries(chatWidgets)) {\n  if (pattern.test(html)) {\n    chatWidgetDetected = chatWidgetDetected || name;\n    chatWidgetCount++;\n  }\n}\n\n// After-hours response indicators\nconst afterHoursIndicators = [\n  /after[\\s-]?hours/gi,\n  /24[\\s]?hour[\\s]?support/gi,\n  /emergency[\\s]?contact/gi,\n  /urgent[\\s]?support/gi,\n  /overnight/gi,\n  /weekend[\\s]?support/gi\n];\n\nlet afterHoursCount = 0;\nfor (const pattern of afterHoursIndicators) {\n  if (pattern.test(html)) afterHoursCount++;\n}\n\n// Calculate response score (higher = better coverage, lower = gap opportunity)\nlet responseScore = 50; // baseline\nif (chatWidgetDetected) responseScore += 20;\nif (afterHoursCount > 0) responseScore += (afterHoursCount * 10);\nif (item.hoursData?.has24x7) responseScore += 30;\nif (item.hoursData?.hasWeekendHours) responseScore += 10;\n\n// Invert for \"gap\" detection - lower company score = bigger gap = better lead\nconst gapScore = 100 - Math.min(responseScore, 100);\n\nreturn [{\n  json: {\n    ...item,\n    afterHoursResponse: {\n      chatWidget: chatWidgetDetected,\n      chatWidgetCount,\n      afterHoursIndicators: afterHoursCount,\n      responseScore,\n      gapScore,\n      hasGap: gapScore > 40\n    }\n  }\n}];"
      },
      "id": "detect-after-hours",
      "name": "Detect After-Hours Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2700, 300]
    },
    {
      "parameters": {
        "jsCode": "// Detect Emergency Language on website\nconst item = $input.first().json;\nconst html = (item.htmlContent || '').toLowerCase();\n\n// Emergency/urgency patterns\nconst emergencyPatterns = [\n  { pattern: /emergency/gi, weight: 3 },\n  { pattern: /urgent/gi, weight: 2 },\n  { pattern: /immediate/gi, weight: 2 },\n  { pattern: /asap/gi, weight: 2 },\n  { pattern: /24[\\/-]7/gi, weight: 3 },\n  { pattern: /same[\\s-]?day/gi, weight: 2 },\n  { pattern: /rush/gi, weight: 1 },\n  { pattern: /critical/gi, weight: 2 },\n  { pattern: /time[\\s-]?sensitive/gi, weight: 2 }\n];\n\nlet urgencyScore = 0;\nlet urgencyTerms = [];\n\nfor (const { pattern, weight } of emergencyPatterns) {\n  const matches = html.match(pattern);\n  if (matches) {\n    urgencyScore += matches.length * weight;\n    urgencyTerms.push(pattern.source.replace(/\\\\|\\[|\\]|\\?|\\-/g, ''));\n  }\n}\n\n// Normalize score to 0-100\nurgencyScore = Math.min(urgencyScore * 5, 100);\n\nreturn [{\n  json: {\n    ...item,\n    emergencyLanguage: {\n      urgencyScore,\n      urgencyTerms: [...new Set(urgencyTerms)].slice(0, 5),\n      hasUrgencyLanguage: urgencyScore > 20\n    }\n  }\n}];"
      },
      "id": "detect-emergency",
      "name": "Detect Emergency Language",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2900, 300]
    },
    {
      "parameters": {
        "jsCode": "// Detect CTA Timing language\nconst item = $input.first().json;\nconst html = (item.htmlContent || '').toLowerCase();\n\n// CTA timing patterns\nconst ctaPatterns = [\n  { pattern: /call now/gi, weight: 3, type: 'immediate' },\n  { pattern: /contact us today/gi, weight: 2, type: 'immediate' },\n  { pattern: /get started/gi, weight: 1, type: 'action' },\n  { pattern: /schedule.*call/gi, weight: 2, type: 'booking' },\n  { pattern: /book.*demo/gi, weight: 2, type: 'booking' },\n  { pattern: /free.*consultation/gi, weight: 2, type: 'booking' },\n  { pattern: /request.*quote/gi, weight: 2, type: 'inquiry' },\n  { pattern: /get.*quote/gi, weight: 2, type: 'inquiry' },\n  { pattern: /limited time/gi, weight: 3, type: 'urgency' },\n  { pattern: /act now/gi, weight: 3, type: 'urgency' },\n  { pattern: /don't wait/gi, weight: 2, type: 'urgency' }\n];\n\nlet ctaScore = 0;\nlet ctaTypes = {};\n\nfor (const { pattern, weight, type } of ctaPatterns) {\n  const matches = html.match(pattern);\n  if (matches) {\n    ctaScore += matches.length * weight;\n    ctaTypes[type] = (ctaTypes[type] || 0) + matches.length;\n  }\n}\n\n// Normalize\nctaScore = Math.min(ctaScore * 4, 100);\n\nreturn [{\n  json: {\n    ...item,\n    ctaTiming: {\n      ctaScore,\n      ctaTypes,\n      hasImmediateCTAs: (ctaTypes.immediate || 0) + (ctaTypes.urgency || 0) > 0,\n      hasBookingCTAs: (ctaTypes.booking || 0) > 0\n    }\n  }\n}];"
      },
      "id": "detect-cta",
      "name": "Detect CTA Timing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3100, 300]
    },
    {
      "parameters": {
        "jsCode": "// Compute After-Hours Signal Score\nconst item = $input.first().json;\n\nconst afterHours = item.afterHoursResponse || {};\nconst emergency = item.emergencyLanguage || {};\nconst cta = item.ctaTiming || {};\nconst hours = item.hoursData || {};\n\n// Weighted scoring for after-hours coverage gap\n// Higher score = bigger gap = better sales opportunity\nlet afterHoursScore = 0;\n\n// Gap detection (no 24/7, no after-hours indicators)\nif (!hours.has24x7) afterHoursScore += 25;\nif (!hours.hasWeekendHours) afterHoursScore += 15;\nif (afterHours.gapScore > 40) afterHoursScore += 20;\n\n// Urgency indicators (they need fast response but may not have it)\nif (emergency.hasUrgencyLanguage) afterHoursScore += 15;\nif (cta.hasImmediateCTAs) afterHoursScore += 15;\n\n// Chat widget presence reduces gap (they have some coverage)\nif (afterHours.chatWidget) afterHoursScore -= 10;\n\nafterHoursScore = Math.max(0, Math.min(afterHoursScore, 100));\n\nreturn [{\n  json: {\n    ...item,\n    signals: {\n      ...item.signals,\n      afterHoursCoverage: {\n        detected: afterHoursScore > 30,\n        score: afterHoursScore,\n        confidence: afterHoursScore > 50 ? 80 : 60,\n        details: {\n          has24x7: hours.has24x7,\n          hasWeekendHours: hours.hasWeekendHours,\n          chatWidget: afterHours.chatWidget,\n          gapScore: afterHours.gapScore,\n          urgencyLanguage: emergency.hasUrgencyLanguage,\n          immediateCTAs: cta.hasImmediateCTAs\n        },\n        reason: afterHoursScore > 50 \n          ? 'Significant after-hours coverage gap detected'\n          : afterHoursScore > 30\n            ? 'Moderate after-hours coverage gap'\n            : 'Good after-hours coverage'\n      }\n    }\n  }\n}];"
      },
      "id": "compute-after-hours",
      "name": "Compute After-Hours Score",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3300, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract Phone Coverage\nconst item = $input.first().json;\nconst html = item.htmlContent || '';\n\n// Phone number patterns\nconst phonePatterns = [\n  /(?:\\+1[\\s.-]?)?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}/g,\n  /\\d{3}[\\s.-]\\d{3}[\\s.-]\\d{4}/g,\n  /tel:[+\\d-]+/gi,\n  /href=\"tel:/gi\n];\n\nlet phoneNumbers = [];\nfor (const pattern of phonePatterns) {\n  const matches = html.match(pattern);\n  if (matches) {\n    phoneNumbers = phoneNumbers.concat(matches);\n  }\n}\n\n// Dedupe and count\nconst uniquePhones = [...new Set(phoneNumbers.map(p => p.replace(/\\D/g, '')))].filter(p => p.length >= 10);\n\n// Check for click-to-call prominence\nconst hasClickToCall = /href=\"tel:/i.test(html);\nconst phoneInHeader = /<header[^>]*>[\\s\\S]*?(?:\\d{3}[\\s.-]?\\d{3}[\\s.-]?\\d{4})[\\s\\S]*?<\\/header>/i.test(html);\n\nlet phoneScore = 0;\nif (uniquePhones.length === 0) phoneScore = 100; // No phone = big gap\nelse if (uniquePhones.length === 1 && !hasClickToCall) phoneScore = 60;\nelse if (!hasClickToCall) phoneScore = 40;\nelse if (!phoneInHeader) phoneScore = 30;\nelse phoneScore = 10;\n\nreturn [{\n  json: {\n    ...item,\n    phoneCoverage: {\n      phoneCount: uniquePhones.length,\n      hasClickToCall,\n      phoneInHeader,\n      phoneScore,\n      hasGap: phoneScore > 40\n    }\n  }\n}];"
      },
      "id": "extract-phone",
      "name": "Extract Phone Coverage",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3500, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract Form Confirmation patterns\nconst item = $input.first().json;\nconst html = (item.htmlContent || '').toLowerCase();\n\n// Form patterns\nconst formPatterns = [\n  /contact[\\s-]?form/gi,\n  /<form[^>]*>/gi,\n  /wpcf7/gi,\n  /hubspot.*form/gi,\n  /typeform/gi,\n  /jotform/gi,\n  /gravity[\\s-]?form/gi\n];\n\nlet formCount = 0;\nlet formTypes = [];\n\nfor (const pattern of formPatterns) {\n  const matches = html.match(pattern);\n  if (matches) {\n    formCount += matches.length;\n    formTypes.push(pattern.source.replace(/\\\\|\\[|\\]|\\?|\\-|\\*|\\./g, ''));\n  }\n}\n\n// Check for form confirmation/thank you indicators\nconst hasThankYou = /thank you|thanks for|we('ll| will) (get back|contact|respond)/i.test(html);\nconst hasResponseTime = /within \\d+ (hour|day|minute|business)/i.test(html);\nconst responseTimeMatch = html.match(/within (\\d+) (hour|day|minute|business)/i);\n\nlet formScore = 50; // baseline\nif (formCount === 0) formScore = 80; // No forms = gap\nelse {\n  if (!hasThankYou) formScore += 15;\n  if (!hasResponseTime) formScore += 20;\n  if (formCount > 3) formScore -= 10; // Multiple forms = more coverage\n}\n\nformScore = Math.max(0, Math.min(formScore, 100));\n\nreturn [{\n  json: {\n    ...item,\n    formConfirmation: {\n      formCount,\n      formTypes: [...new Set(formTypes)],\n      hasThankYou,\n      hasResponseTime,\n      statedResponseTime: responseTimeMatch ? `${responseTimeMatch[1]} ${responseTimeMatch[2]}s` : null,\n      formScore,\n      hasGap: formScore > 50\n    }\n  }\n}];"
      },
      "id": "extract-form",
      "name": "Extract Form Confirmation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3700, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract Response Speed Language\nconst item = $input.first().json;\nconst html = (item.htmlContent || '').toLowerCase();\n\n// Response time patterns\nconst speedPatterns = [\n  { pattern: /respond.*within.*minute/gi, speed: 'fast', score: 10 },\n  { pattern: /respond.*within.*hour/gi, speed: 'medium', score: 20 },\n  { pattern: /respond.*within.*24/gi, speed: 'slow', score: 40 },\n  { pattern: /respond.*within.*day/gi, speed: 'slow', score: 50 },\n  { pattern: /respond.*within.*48/gi, speed: 'very_slow', score: 70 },\n  { pattern: /get back.*soon/gi, speed: 'vague', score: 60 },\n  { pattern: /as soon as possible/gi, speed: 'vague', score: 50 },\n  { pattern: /instant.*response/gi, speed: 'instant', score: 5 },\n  { pattern: /immediate.*response/gi, speed: 'instant', score: 5 },\n  { pattern: /real[\\s-]?time/gi, speed: 'instant', score: 5 }\n];\n\nlet speedScore = 70; // Default assumes no speed commitment = gap\nlet speedIndicators = [];\nlet detectedSpeed = 'unknown';\n\nfor (const { pattern, speed, score } of speedPatterns) {\n  if (pattern.test(html)) {\n    speedIndicators.push(speed);\n    if (score < speedScore) {\n      speedScore = score;\n      detectedSpeed = speed;\n    }\n  }\n}\n\nreturn [{\n  json: {\n    ...item,\n    responseSpeed: {\n      speedScore,\n      detectedSpeed,\n      speedIndicators: [...new Set(speedIndicators)],\n      hasSpeedCommitment: speedIndicators.length > 0,\n      hasGap: speedScore > 40\n    }\n  }\n}];"
      },
      "id": "extract-speed",
      "name": "Extract Response Speed Language",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3900, 300]
    },
    {
      "parameters": {
        "jsCode": "// Detect Redundancy (multiple contact methods)\nconst item = $input.first().json;\nconst html = (item.htmlContent || '').toLowerCase();\n\n// Contact method patterns\nconst contactMethods = {\n  phone: item.phoneCoverage?.phoneCount > 0,\n  email: /mailto:|email.*@|@[a-z]+\\.[a-z]/i.test(html),\n  chat: !!item.afterHoursResponse?.chatWidget,\n  form: item.formConfirmation?.formCount > 0,\n  booking: /calendly|hubspot.*meeting|acuity|savvycal|chilipiper/i.test(html),\n  socialDM: /message us on|dm us|contact.*twitter|contact.*linkedin/i.test(html),\n  whatsapp: /whatsapp|wa\\.me/i.test(html),\n  sms: /text us|sms/i.test(html)\n};\n\nconst methodCount = Object.values(contactMethods).filter(Boolean).length;\nconst methods = Object.entries(contactMethods).filter(([k, v]) => v).map(([k]) => k);\n\n// Lower redundancy = higher gap score\nlet redundancyScore;\nif (methodCount >= 5) redundancyScore = 10;\nelse if (methodCount >= 4) redundancyScore = 25;\nelse if (methodCount >= 3) redundancyScore = 40;\nelse if (methodCount >= 2) redundancyScore = 60;\nelse if (methodCount >= 1) redundancyScore = 80;\nelse redundancyScore = 100;\n\nreturn [{\n  json: {\n    ...item,\n    redundancy: {\n      methodCount,\n      methods,\n      contactMethods,\n      redundancyScore,\n      hasGap: redundancyScore > 50\n    }\n  }\n}];"
      },
      "id": "detect-redundancy",
      "name": "Detect Redundancy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4100, 300]
    },
    {
      "parameters": {
        "jsCode": "// Compute Inbound Risk Score\nconst item = $input.first().json;\n\nconst phone = item.phoneCoverage || {};\nconst form = item.formConfirmation || {};\nconst speed = item.responseSpeed || {};\nconst redundancy = item.redundancy || {};\n\n// Weighted average of all inbound risk factors\nconst weights = {\n  phone: 0.25,\n  form: 0.25,\n  speed: 0.30,\n  redundancy: 0.20\n};\n\nconst inboundRiskScore = Math.round(\n  (phone.phoneScore || 50) * weights.phone +\n  (form.formScore || 50) * weights.form +\n  (speed.speedScore || 50) * weights.speed +\n  (redundancy.redundancyScore || 50) * weights.redundancy\n);\n\n// Determine risk level\nlet riskLevel;\nif (inboundRiskScore >= 70) riskLevel = 'high';\nelse if (inboundRiskScore >= 50) riskLevel = 'medium';\nelse if (inboundRiskScore >= 30) riskLevel = 'low';\nelse riskLevel = 'minimal';\n\nreturn [{\n  json: {\n    ...item,\n    signals: {\n      ...item.signals,\n      inboundRisk: {\n        detected: inboundRiskScore > 45,\n        score: inboundRiskScore,\n        confidence: inboundRiskScore > 60 ? 85 : 65,\n        riskLevel,\n        details: {\n          phoneScore: phone.phoneScore,\n          formScore: form.formScore,\n          speedScore: speed.speedScore,\n          redundancyScore: redundancy.redundancyScore,\n          contactMethods: redundancy.methods\n        },\n        reason: riskLevel === 'high'\n          ? 'High risk of losing inbound leads - poor contact coverage'\n          : riskLevel === 'medium'\n            ? 'Moderate inbound response risk'\n            : 'Good inbound lead handling'\n      }\n    }\n  }\n}];"
      },
      "id": "compute-inbound-risk",
      "name": "Compute Inbound Risk Score",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4300, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "linkedin-check",
              "leftValue": "={{ $json.config.includeLinkedIn }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "include-linkedin",
      "name": "Include LinkedIn?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [4500, 300]
    },
    {
      "parameters": {
        "url": "=https://www.linkedin.com/company/{{$json.domain.split('.')[0]}}/jobs/",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "linkedin-discovery",
      "name": "LinkedIn Discovery",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4700, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse LinkedIn Hiring data\nconst item = $input.first().json;\nconst html = item.data || '';\n\n// Check for job postings indicators\nconst jobIndicators = [\n  /\\d+ job/gi,\n  /hiring/gi,\n  /open position/gi,\n  /we're growing/gi,\n  /join our team/gi\n];\n\nlet jobCount = 0;\nlet hiringSignals = [];\n\nfor (const pattern of jobIndicators) {\n  const matches = html.match(pattern);\n  if (matches) {\n    hiringSignals = hiringSignals.concat(matches);\n    // Try to extract job count\n    const countMatch = matches.join(' ').match(/(\\d+)\\s*job/i);\n    if (countMatch) {\n      jobCount = Math.max(jobCount, parseInt(countMatch[1]));\n    }\n  }\n}\n\nconst isHiring = hiringSignals.length > 0 || jobCount > 0;\n\n// Hiring score - more jobs = potentially better lead\nlet hiringScore = 0;\nif (jobCount >= 10) hiringScore = 90;\nelse if (jobCount >= 5) hiringScore = 70;\nelse if (jobCount >= 2) hiringScore = 50;\nelse if (isHiring) hiringScore = 30;\n\nreturn [{\n  json: {\n    ...item,\n    signals: {\n      ...item.signals,\n      linkedInHiring: {\n        detected: isHiring,\n        score: hiringScore,\n        confidence: isHiring ? 70 : 0,\n        jobCount,\n        hiringSignals: [...new Set(hiringSignals)].slice(0, 5),\n        reason: jobCount > 5\n          ? `Actively hiring - ${jobCount} open positions`\n          : isHiring\n            ? 'Active hiring signals detected'\n            : 'No hiring activity detected'\n      }\n    }\n  }\n}];"
      },
      "id": "parse-linkedin",
      "name": "Parse LinkedIn Hiring",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4900, 200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "indeed-check",
              "leftValue": "={{ $json.config.includeIndeed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "include-indeed",
      "name": "Include Indeed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [5100, 300]
    },
    {
      "parameters": {
        "url": "=https://www.indeed.com/cmp/{{$json.domain.split('.')[0]}}/jobs",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "indeed-discovery",
      "name": "Indeed Discovery",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [5300, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Parse Indeed Jobs data\nconst item = $input.first().json;\nconst html = item.data || '';\n\n// Look for job listing indicators\nconst jobMatches = html.match(/(\\d+)\\s*jobs?\\s*(found|available|posted)/gi) || [];\nlet indeedJobCount = 0;\n\nfor (const match of jobMatches) {\n  const num = parseInt(match.match(/\\d+/)?.[0] || '0');\n  indeedJobCount = Math.max(indeedJobCount, num);\n}\n\n// Alternative: count job cards\nconst jobCardCount = (html.match(/job_seen_beacon|jobsearch-ResultsList/gi) || []).length;\nif (jobCardCount > indeedJobCount) {\n  indeedJobCount = Math.min(jobCardCount, 50);\n}\n\nconst hasJobs = indeedJobCount > 0;\n\nlet indeedScore = 0;\nif (indeedJobCount >= 20) indeedScore = 95;\nelse if (indeedJobCount >= 10) indeedScore = 80;\nelse if (indeedJobCount >= 5) indeedScore = 60;\nelse if (indeedJobCount >= 1) indeedScore = 40;\n\nreturn [{\n  json: {\n    ...item,\n    signals: {\n      ...item.signals,\n      indeedJobs: {\n        detected: hasJobs,\n        score: indeedScore,\n        confidence: hasJobs ? 75 : 0,\n        jobCount: indeedJobCount,\n        reason: indeedJobCount > 10\n          ? `High hiring volume - ${indeedJobCount} jobs on Indeed`\n          : hasJobs\n            ? `Active on Indeed - ${indeedJobCount} job(s) posted`\n            : 'No Indeed job postings found'\n      }\n    }\n  }\n}];"
      },
      "id": "parse-indeed",
      "name": "Parse Indeed Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5500, 200]
    },
    {
      "parameters": {
        "jsCode": "// Compute Total Score\nconst item = $input.first().json;\nconst signals = item.signals || {};\n\n// Signal weights\nconst weights = {\n  googleAds: 0.30,        // Active ad spend is strong buying signal\n  afterHoursCoverage: 0.25, // Coverage gap = opportunity\n  inboundRisk: 0.25,      // Response risk = opportunity\n  linkedInHiring: 0.10,   // Hiring = growth\n  indeedJobs: 0.10        // More hiring data\n};\n\nlet totalScore = 0;\nlet detectedSignals = [];\n\nfor (const [key, weight] of Object.entries(weights)) {\n  const signal = signals[key];\n  if (signal?.detected) {\n    detectedSignals.push(key);\n    // Use signal score weighted by confidence\n    const signalValue = (signal.score || 50) * (signal.confidence || 50) / 100;\n    totalScore += signalValue * weight;\n  }\n}\n\n// Normalize to 0-100\ntotalScore = Math.round(Math.min(totalScore * 1.5, 100));\n\n// Boost if multiple signals detected\nif (detectedSignals.length >= 3) totalScore = Math.min(totalScore + 10, 100);\nif (detectedSignals.length >= 4) totalScore = Math.min(totalScore + 5, 100);\n\nreturn [{\n  json: {\n    ...item,\n    totalScore,\n    detectedSignals,\n    signalCount: detectedSignals.length\n  }\n}];"
      },
      "id": "compute-total-score",
      "name": "Compute Total Score",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5700, 300]
    },
    {
      "parameters": {
        "jsCode": "// Compute Confidence Level\nconst item = $input.first().json;\nconst signals = item.signals || {};\n\n// Calculate overall confidence based on data quality\nlet dataPoints = 0;\nlet confidenceSum = 0;\n\nfor (const signal of Object.values(signals)) {\n  if (signal && typeof signal === 'object') {\n    dataPoints++;\n    confidenceSum += signal.confidence || 0;\n  }\n}\n\nconst avgConfidence = dataPoints > 0 ? Math.round(confidenceSum / dataPoints) : 0;\n\n// Adjust based on signal count\nlet confidenceLevel;\nif (avgConfidence >= 75 && item.signalCount >= 3) confidenceLevel = 'high';\nelse if (avgConfidence >= 60 && item.signalCount >= 2) confidenceLevel = 'medium';\nelse if (avgConfidence >= 40) confidenceLevel = 'low';\nelse confidenceLevel = 'very_low';\n\nreturn [{\n  json: {\n    ...item,\n    confidence: {\n      level: confidenceLevel,\n      score: avgConfidence,\n      dataPoints\n    }\n  }\n}];"
      },
      "id": "compute-confidence",
      "name": "Compute Confidence Level",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5900, 300]
    },
    {
      "parameters": {
        "jsCode": "// Determine Ready State\nconst item = $input.first().json;\n\nconst score = item.totalScore || 0;\nconst confidence = item.confidence?.level || 'low';\nconst signalCount = item.signalCount || 0;\n\nlet readyState;\nlet readyReason;\n\nif (score >= 70 && (confidence === 'high' || confidence === 'medium') && signalCount >= 2) {\n  readyState = 'hot';\n  readyReason = 'High-intent lead with multiple strong signals';\n} else if (score >= 50 && signalCount >= 2) {\n  readyState = 'warm';\n  readyReason = 'Good potential with verified signals';\n} else if (score >= 30 && signalCount >= 1) {\n  readyState = 'nurture';\n  readyReason = 'Some signals detected - worth monitoring';\n} else {\n  readyState = 'cold';\n  readyReason = 'Limited signals - low priority';\n}\n\nreturn [{\n  json: {\n    ...item,\n    readyState,\n    readyReason\n  }\n}];"
      },
      "id": "determine-ready-state",
      "name": "Determine Ready State",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6100, 300]
    },
    {
      "parameters": {
        "jsCode": "// Decide Contact Method\nconst item = $input.first().json;\nconst signals = item.signals || {};\n\nlet contactMethod;\nlet contactReason;\n\n// Prioritize based on detected signals\nif (signals.afterHoursCoverage?.detected && signals.afterHoursCoverage.score > 60) {\n  contactMethod = 'phone_call';\n  contactReason = 'After-hours gap - demonstrate immediate response capability';\n} else if (signals.inboundRisk?.detected && signals.inboundRisk.riskLevel === 'high') {\n  contactMethod = 'email_sequence';\n  contactReason = 'Inbound risk - show faster response alternatives';\n} else if (signals.linkedInHiring?.detected || signals.indeedJobs?.detected) {\n  contactMethod = 'linkedin_outreach';\n  contactReason = 'Hiring activity - connect during growth phase';\n} else if (item.readyState === 'hot') {\n  contactMethod = 'phone_call';\n  contactReason = 'Hot lead - direct outreach recommended';\n} else if (item.readyState === 'warm') {\n  contactMethod = 'email_sequence';\n  contactReason = 'Warm lead - nurture with targeted content';\n} else {\n  contactMethod = 'marketing_nurture';\n  contactReason = 'Add to nurture campaign for long-term engagement';\n}\n\nreturn [{\n  json: {\n    ...item,\n    recommendedContact: {\n      method: contactMethod,\n      reason: contactReason\n    }\n  }\n}];"
      },
      "id": "decide-contact",
      "name": "Decide Contact Method",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6300, 300]
    },
    {
      "parameters": {
        "jsCode": "// Generate Explanation (\"Why Now\" message)\nconst item = $input.first().json;\nconst signals = item.signals || {};\n\nlet whyNow = [];\nlet keyInsights = [];\n\n// Build explanation based on detected signals\nif (signals.googleAds?.detected) {\n  whyNow.push('Actively spending on Google Ads');\n  keyInsights.push(`Ad presence: ${signals.googleAds.details || 'Confirmed'}`);\n}\n\nif (signals.afterHoursCoverage?.detected) {\n  const gap = signals.afterHoursCoverage;\n  if (gap.score > 60) {\n    whyNow.push('Significant after-hours coverage gap');\n  } else {\n    whyNow.push('Moderate after-hours coverage opportunity');\n  }\n  if (!gap.details?.has24x7) keyInsights.push('No 24/7 coverage advertised');\n  if (!gap.details?.chatWidget) keyInsights.push('No live chat detected');\n}\n\nif (signals.inboundRisk?.detected) {\n  const risk = signals.inboundRisk;\n  whyNow.push(`${risk.riskLevel.charAt(0).toUpperCase() + risk.riskLevel.slice(1)} inbound response risk`);\n  if (risk.details?.contactMethods) {\n    keyInsights.push(`Contact methods: ${risk.details.contactMethods.join(', ')}`);\n  }\n}\n\nif (signals.linkedInHiring?.detected || signals.indeedJobs?.detected) {\n  const linkedIn = signals.linkedInHiring?.jobCount || 0;\n  const indeed = signals.indeedJobs?.jobCount || 0;\n  const totalJobs = linkedIn + indeed;\n  whyNow.push(`Growth mode - ${totalJobs} open position(s)`);\n  keyInsights.push('Company is actively scaling');\n}\n\n// Create summary\nconst explanation = whyNow.length > 0\n  ? whyNow.join(' + ')\n  : 'Limited buying signals detected';\n\nreturn [{\n  json: {\n    ...item,\n    explanation,\n    whyNow: explanation,\n    keyInsights\n  }\n}];"
      },
      "id": "generate-explanation",
      "name": "Generate Explanation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6500, 300]
    },
    {
      "parameters": {
        "jsCode": "// Set Timestamps\nconst item = $input.first().json;\n\nreturn [{\n  json: {\n    ...item,\n    timestamps: {\n      scrapedAt: new Date().toISOString(),\n      expiresAt: new Date(Date.now() + 86400000).toISOString() // 24 hours\n    }\n  }\n}];"
      },
      "id": "set-timestamps",
      "name": "Set Timestamps",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6700, 300]
    },
    {
      "parameters": {
        "jsCode": "// Format Output - Clean up for response\nconst item = $input.first().json;\n\n// Build clean signal array for frontend\nconst signalArray = [];\nconst signals = item.signals || {};\n\nif (signals.googleAds?.detected) {\n  signalArray.push({\n    id: 'googlePaidTraffic',\n    label: 'Google Paid Traffic Active',\n    detected: true,\n    value: signals.googleAds.details || 'Active Google Ads detected',\n    confidence: signals.googleAds.confidence,\n    score: signals.googleAds.score\n  });\n}\n\nif (signals.afterHoursCoverage?.detected) {\n  signalArray.push({\n    id: 'afterHoursCoverage',\n    label: 'After Hours Coverage Gap',\n    detected: true,\n    value: signals.afterHoursCoverage.reason,\n    confidence: signals.afterHoursCoverage.confidence,\n    score: signals.afterHoursCoverage.score\n  });\n}\n\nif (signals.inboundRisk?.detected) {\n  signalArray.push({\n    id: 'inboundResponseRisk',\n    label: 'Inbound Response Risk',\n    detected: true,\n    value: signals.inboundRisk.reason,\n    confidence: signals.inboundRisk.confidence,\n    score: signals.inboundRisk.score\n  });\n}\n\nif (signals.linkedInHiring?.detected) {\n  signalArray.push({\n    id: 'linkedInHiring',\n    label: 'LinkedIn Hiring Activity',\n    detected: true,\n    value: signals.linkedInHiring.reason,\n    confidence: signals.linkedInHiring.confidence,\n    score: signals.linkedInHiring.score\n  });\n}\n\nif (signals.indeedJobs?.detected) {\n  signalArray.push({\n    id: 'indeedJobs',\n    label: 'Indeed Job Postings',\n    detected: true,\n    value: signals.indeedJobs.reason,\n    confidence: signals.indeedJobs.confidence,\n    score: signals.indeedJobs.score\n  });\n}\n\nreturn [{\n  json: {\n    domain: item.domain,\n    originalDomain: item.originalDomain,\n    score: item.totalScore || 0,\n    signals: signalArray,\n    signalCount: signalArray.length,\n    whyNow: item.whyNow || item.explanation,\n    keyInsights: item.keyInsights || [],\n    readyState: item.readyState,\n    readyReason: item.readyReason,\n    confidence: item.confidence,\n    recommendedContact: item.recommendedContact,\n    disqualified: item.disqualified || false,\n    disqualifyReason: item.disqualifyReason || null,\n    timestamps: item.timestamps,\n    websiteAnalysis: {\n      chatWidget: item.afterHoursResponse?.chatWidget,\n      hasChatWidget: !!item.afterHoursResponse?.chatWidget,\n      hasBookingTool: item.ctaTiming?.hasBookingCTAs,\n      hasContactForm: item.formConfirmation?.formCount > 0,\n      contactMethods: item.redundancy?.methods || []\n    }\n  }\n}];"
      },
      "id": "format-output",
      "name": "Format Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [6900, 300]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [7100, 400]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Access-Control-Allow-Origin",
                "value": "*"
              }
            ]
          }
        }
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [7300, 400]
    },
    {
      "parameters": {
        "jsCode": "// Skip to scoring - used when LinkedIn/Indeed are disabled\nconst item = $input.first().json;\nreturn [{ json: item }];"
      },
      "id": "skip-linkedin",
      "name": "Skip LinkedIn",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4700, 400]
    },
    {
      "parameters": {
        "jsCode": "// Skip to scoring - used when Indeed is disabled\nconst item = $input.first().json;\nreturn [{ json: item }];"
      },
      "id": "skip-indeed",
      "name": "Skip Indeed",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5300, 400]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "merge-linkedin",
      "name": "Merge LinkedIn",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [5100, 300]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "merge-indeed",
      "name": "Merge Indeed",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [5700, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Normalize Inputs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Inputs": {
      "main": [
        [
          {
            "node": "Loop Domains",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Domains": {
      "main": [
        [
          {
            "node": "Cache Fresh?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Fresh?": {
      "main": [
        [
          {
            "node": "SERP Discovery",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "SERP Discovery",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SERP Discovery": {
      "main": [
        [
          {
            "node": "Extract Domain from SERP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Domain from SERP": {
      "main": [
        [
          {
            "node": "Fetch SERP for Ads",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch SERP for Ads": {
      "main": [
        [
          {
            "node": "Parse Ads Presence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Ads Presence": {
      "main": [
        [
          {
            "node": "Check Ads Transparency API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Ads Transparency API": {
      "main": [
        [
          {
            "node": "Store Ads Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Ads Result": {
      "main": [
        [
          {
            "node": "Ads Present?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ads Present?": {
      "main": [
        [
          {
            "node": "Scrape Website",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "BLOCK (Disqualified)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "BLOCK (Disqualified)": {
      "main": [
        [
          {
            "node": "Format Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Scrape Website": {
      "main": [
        [
          {
            "node": "Extract Business Hours",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Business Hours": {
      "main": [
        [
          {
            "node": "Detect After-Hours Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect After-Hours Response": {
      "main": [
        [
          {
            "node": "Detect Emergency Language",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Emergency Language": {
      "main": [
        [
          {
            "node": "Detect CTA Timing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect CTA Timing": {
      "main": [
        [
          {
            "node": "Compute After-Hours Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute After-Hours Score": {
      "main": [
        [
          {
            "node": "Extract Phone Coverage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Phone Coverage": {
      "main": [
        [
          {
            "node": "Extract Form Confirmation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Form Confirmation": {
      "main": [
        [
          {
            "node": "Extract Response Speed Language",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Response Speed Language": {
      "main": [
        [
          {
            "node": "Detect Redundancy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Redundancy": {
      "main": [
        [
          {
            "node": "Compute Inbound Risk Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Inbound Risk Score": {
      "main": [
        [
          {
            "node": "Include LinkedIn?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Include LinkedIn?": {
      "main": [
        [
          {
            "node": "LinkedIn Discovery",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip LinkedIn",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LinkedIn Discovery": {
      "main": [
        [
          {
            "node": "Parse LinkedIn Hiring",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LinkedIn Hiring": {
      "main": [
        [
          {
            "node": "Include Indeed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip LinkedIn": {
      "main": [
        [
          {
            "node": "Include Indeed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Include Indeed?": {
      "main": [
        [
          {
            "node": "Indeed Discovery",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Skip Indeed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Indeed Discovery": {
      "main": [
        [
          {
            "node": "Parse Indeed Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Indeed Jobs": {
      "main": [
        [
          {
            "node": "Compute Total Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Skip Indeed": {
      "main": [
        [
          {
            "node": "Compute Total Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Total Score": {
      "main": [
        [
          {
            "node": "Compute Confidence Level",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Confidence Level": {
      "main": [
        [
          {
            "node": "Determine Ready State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Determine Ready State": {
      "main": [
        [
          {
            "node": "Decide Contact Method",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Decide Contact Method": {
      "main": [
        [
          {
            "node": "Generate Explanation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Explanation": {
      "main": [
        [
          {
            "node": "Set Timestamps",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Timestamps": {
      "main": [
        [
          {
            "node": "Format Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Output": {
      "main": [
        [
          {
            "node": "Loop Domains",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "SAI Scraper"
    },
    {
      "name": "Enhanced"
    }
  ]
}
