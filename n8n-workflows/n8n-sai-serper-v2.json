{
  "name": "SAI Scraper - Serper API v2",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "sai-scraper-serper-v2",
        "responseMode": "responseNode",
        "options": { "allowedOrigins": "*" }
      },
      "id": "webhook-trigger",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [100, 500],
      "webhookId": "sai-scraper-serper-v2"
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body || {};\nconst domains = body.domains || [];\nconst options = body.options || {};\n\nconst SERPER_API_KEY = options.serperApiKey || 'YOUR_SERPER_API_KEY';\n\nconst config = {\n  serperApiKey: SERPER_API_KEY,\n  signalWeights: {\n    googleAds: 0.30,\n    afterHoursCoverage: 0.25,\n    inboundRisk: 0.20,\n    hiringSignals: 0.15,\n    techStack: 0.10\n  }\n};\n\nreturn domains.map((domain, index) => {\n  let cleanDomain = domain\n    .replace(/^https?:\\/\\//, '')\n    .replace(/^www\\./, '')\n    .split('/')[0]\n    .toLowerCase()\n    .trim();\n  \n  const companyName = cleanDomain\n    .replace(/\\.(com|io|co|net|org|ai|app)$/, '')\n    .replace(/[-_]/g, ' ')\n    .split('.')\n    .pop()\n    .replace(/\\b\\w/g, c => c.toUpperCase());\n  \n  return {\n    json: {\n      domain: cleanDomain,\n      companyName,\n      config,\n      index,\n      timestamp: Date.now(),\n      signals: {},\n      enrichment: {},\n      errors: []\n    }\n  };\n});"
      },
      "id": "normalize-inputs",
      "name": "Normalize Inputs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [300, 500]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": { "delayBetweenBatches": 500 }
      },
      "id": "loop-domains",
      "name": "Loop Domains",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [500, 500]
    },
    {
      "parameters": {
        "jsCode": "// ALL-IN-ONE: Serper searches + analysis for single domain\nconst item = $input.first().json;\nconst domain = item.domain;\nconst companyName = item.companyName;\nconst config = item.config;\nconst apiKey = config.serperApiKey;\n\n// Helper function to make Serper API call\nasync function serperSearch(query) {\n  try {\n    const response = await fetch('https://google.serper.dev/search', {\n      method: 'POST',\n      headers: {\n        'X-API-KEY': apiKey,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        q: query,\n        gl: 'us',\n        hl: 'en',\n        num: 20\n      })\n    });\n    if (!response.ok) throw new Error(`Serper error: ${response.status}`);\n    return await response.json();\n  } catch (e) {\n    return { error: e.message };\n  }\n}\n\n// Run all 3 searches in parallel\nconst [adsResult, hiringResult, linkedInResult] = await Promise.all([\n  serperSearch(domain),\n  serperSearch(`\"${companyName}\" hiring jobs careers`),\n  serperSearch(`\"${companyName}\" site:linkedin.com/company`)\n]);\n\n// ===== ANALYZE GOOGLE ADS =====\nlet googleAdsDetected = false;\nlet adCount = 0;\nlet adDetails = [];\n\nif (adsResult.ads && adsResult.ads.length > 0) {\n  googleAdsDetected = true;\n  adCount = adsResult.ads.length;\n  \n  const domainAds = adsResult.ads.filter(ad => \n    (ad.link && ad.link.includes(domain)) ||\n    (ad.displayLink && ad.displayLink.includes(domain))\n  );\n  \n  if (domainAds.length > 0) {\n    adDetails.push(`${domainAds.length} ads from ${domain}`);\n  }\n  adDetails.push(`${adCount} total ads in SERP`);\n}\n\nconst googleAdsSignal = {\n  detected: googleAdsDetected,\n  score: googleAdsDetected ? Math.min(60 + (adCount * 5), 95) : 0,\n  confidence: googleAdsDetected ? 90 : 0,\n  adCount,\n  source: 'serper_api',\n  details: googleAdsDetected ? adDetails.join('; ') : 'No Google Ads detected'\n};\n\n// ===== ANALYZE HIRING =====\nlet hiringDetected = false;\nlet jobCount = 0;\nlet hiringRoles = [];\nlet hiringPlatforms = [];\n\nconst hiringOrganic = hiringResult.organic || [];\nfor (const result of hiringOrganic) {\n  const title = (result.title || '').toLowerCase();\n  const snippet = (result.snippet || '').toLowerCase();\n  const link = (result.link || '').toLowerCase();\n  const combined = title + ' ' + snippet;\n  \n  if (link.includes('linkedin.com/jobs') || link.includes('linkedin.com/company')) {\n    if (!hiringPlatforms.includes('LinkedIn')) hiringPlatforms.push('LinkedIn');\n    hiringDetected = true;\n  }\n  if (link.includes('indeed.com')) {\n    if (!hiringPlatforms.includes('Indeed')) hiringPlatforms.push('Indeed');\n    hiringDetected = true;\n  }\n  if (link.includes('glassdoor.com')) {\n    if (!hiringPlatforms.includes('Glassdoor')) hiringPlatforms.push('Glassdoor');\n    hiringDetected = true;\n  }\n  \n  const countMatch = combined.match(/(\\d+)\\s*(job|position|opening)/i);\n  if (countMatch) {\n    jobCount = Math.max(jobCount, parseInt(countMatch[1]));\n    hiringDetected = true;\n  }\n  \n  const rolePatterns = [\n    { pattern: /sales|account executive/i, role: 'Sales' },\n    { pattern: /sdr|bdr|business development/i, role: 'SDR/BDR' },\n    { pattern: /customer success/i, role: 'Customer Success' },\n    { pattern: /marketing|growth/i, role: 'Marketing' },\n    { pattern: /engineer|developer/i, role: 'Engineering' }\n  ];\n  \n  for (const { pattern, role } of rolePatterns) {\n    if (pattern.test(combined) && !hiringRoles.includes(role)) {\n      hiringRoles.push(role);\n      hiringDetected = true;\n    }\n  }\n}\n\nlet hiringScore = 0;\nif (hiringDetected) {\n  hiringScore = Math.min(50 + (hiringRoles.length * 10) + (hiringPlatforms.length * 10), 90);\n  if (hiringRoles.includes('Sales') || hiringRoles.includes('SDR/BDR')) {\n    hiringScore = Math.min(hiringScore + 15, 95);\n  }\n}\n\nconst hiringSignal = {\n  detected: hiringDetected,\n  score: hiringScore,\n  confidence: hiringDetected ? Math.min(50 + hiringPlatforms.length * 15, 85) : 0,\n  jobCount,\n  roles: hiringRoles,\n  platforms: hiringPlatforms,\n  details: hiringDetected \n    ? `Hiring: ${hiringRoles.join(', ') || 'various'} via ${hiringPlatforms.join(', ') || 'job boards'}`\n    : 'No hiring signals'\n};\n\n// ===== EXTRACT LINKEDIN =====\nlet linkedInFound = false;\nlet linkedInUrl = null;\nlet employeeCount = null;\nlet employeeRange = null;\n\nconst linkedInOrganic = linkedInResult.organic || [];\nfor (const result of linkedInOrganic) {\n  const link = result.link || '';\n  const urlMatch = link.match(/linkedin\\.com\\/company\\/([a-zA-Z0-9-]+)/i);\n  \n  if (urlMatch) {\n    linkedInFound = true;\n    linkedInUrl = `https://linkedin.com/company/${urlMatch[1]}`;\n    \n    const snippet = result.snippet || '';\n    const empMatch = snippet.match(/(\\d[\\d,]*)\\s*(?:followers|employees)/i);\n    if (empMatch) {\n      employeeCount = parseInt(empMatch[1].replace(/,/g, ''));\n      if (employeeCount <= 10) employeeRange = '1-10';\n      else if (employeeCount <= 50) employeeRange = '11-50';\n      else if (employeeCount <= 200) employeeRange = '51-200';\n      else if (employeeCount <= 500) employeeRange = '201-500';\n      else if (employeeCount <= 1000) employeeRange = '501-1000';\n      else employeeRange = '1000+';\n    }\n    break;\n  }\n}\n\nreturn [{\n  json: {\n    ...item,\n    signals: {\n      googleAds: googleAdsSignal,\n      hiring: hiringSignal\n    },\n    enrichment: {\n      linkedIn: {\n        found: linkedInFound,\n        url: linkedInUrl,\n        employeeCount,\n        employeeRange\n      }\n    },\n    serperCreditsUsed: 3\n  }\n}];"
      },
      "id": "serper-all-in-one",
      "name": "Serper All-In-One",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [700, 500]
    },
    {
      "parameters": {
        "url": "=https://{{$json.domain}}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "User-Agent", "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36" },
            { "name": "Accept", "value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" }
          ]
        },
        "options": { "timeout": 15000, "redirect": { "redirect": { "followRedirects": true, "maxRedirects": 5 } } }
      },
      "id": "scrape-website",
      "name": "Scrape Website",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 500],
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json;\nconst rawHtml = item.data || '';\nconst html = rawHtml.toLowerCase();\n\nconst scrapeSuccess = rawHtml.length > 1000 && \n  !rawHtml.includes('403 Forbidden') && \n  !rawHtml.includes('Access Denied') &&\n  !rawHtml.includes('Just a moment') && \n  !rawHtml.includes('captcha');\n\nif (!scrapeSuccess) {\n  return [{\n    json: {\n      ...item,\n      data: undefined,\n      scrapeSuccess: false,\n      websiteAnalysis: {\n        hasChatWidget: false, hasBookingTool: false, hasContactForm: false,\n        hasPhone: false, has24x7: false, contactMethods: []\n      },\n      techStack: { detected: [], confidence: 0 }\n    }\n  }];\n}\n\n// Chat widgets\nconst chatWidgets = {\n  intercom: /intercom|intercomcdn/i,\n  drift: /drift\\.com|driftt/i,\n  zendesk: /zendesk|zopim|zdassets/i,\n  hubspot: /hubspot.*conversations/i,\n  crisp: /crisp\\.chat/i,\n  tawk: /tawk\\.to/i,\n  tidio: /tidio\\.co/i\n};\n\nlet chatWidget = null;\nfor (const [name, pattern] of Object.entries(chatWidgets)) {\n  if (pattern.test(rawHtml)) { chatWidget = name; break; }\n}\n\n// Booking tools\nconst bookingTools = {\n  calendly: /calendly\\.com/i,\n  hubspotMeetings: /meetings\\.hubspot\\.com/i,\n  chilipiper: /chilipiper/i,\n  acuity: /acuityscheduling/i\n};\n\nlet bookingTool = null;\nfor (const [name, pattern] of Object.entries(bookingTools)) {\n  if (pattern.test(rawHtml)) { bookingTool = name; break; }\n}\n\n// Contact info\nconst hasPhone = /(?:\\+1[\\s.-]?)?\\(?\\d{3}\\)?[\\s.-]?\\d{3}[\\s.-]?\\d{4}/.test(rawHtml) || /href=\"tel:/i.test(rawHtml);\nconst hasClickToCall = /href=\"tel:/i.test(rawHtml);\nconst hasTollFree = /1-8[0-9]{2}-/i.test(rawHtml);\nconst hasContactForm = /<form[^>]*(?:contact|inquiry|lead|quote)/i.test(rawHtml) || /contact-form|wpcf7|hs-form/i.test(rawHtml);\n\n// Hours\nconst has24x7 = /24\\/7|24 hours|always open/i.test(html);\nconst hasWeekendHours = /saturday|sunday|weekend/i.test(html);\n\n// Tech stack\nconst techPatterns = {\n  hubspot: /hubspot|hs-scripts|hbspt/i,\n  salesforce: /salesforce|pardot/i,\n  marketo: /marketo|munchkin/i,\n  intercom: /intercom/i,\n  googleAnalytics: /gtag|googletagmanager/i,\n  hotjar: /hotjar/i,\n  stripe: /stripe\\.com/i\n};\n\nlet techStack = [];\nfor (const [name, pattern] of Object.entries(techPatterns)) {\n  if (pattern.test(rawHtml)) techStack.push(name);\n}\n\nconst contactMethods = [];\nif (hasPhone) contactMethods.push('phone');\nif (chatWidget) contactMethods.push('chat');\nif (hasContactForm) contactMethods.push('form');\nif (bookingTool) contactMethods.push('booking');\n\nreturn [{\n  json: {\n    ...item,\n    data: undefined,\n    scrapeSuccess: true,\n    websiteAnalysis: {\n      chatWidget,\n      hasChatWidget: !!chatWidget,\n      bookingTool,\n      hasBookingTool: !!bookingTool,\n      hasContactForm,\n      hasPhone,\n      hasClickToCall,\n      hasTollFree,\n      contactMethods,\n      contactMethodCount: contactMethods.length,\n      has24x7,\n      hasWeekendHours\n    },\n    techStack: {\n      detected: techStack,\n      count: techStack.length,\n      confidence: techStack.length > 0 ? Math.min(60 + techStack.length * 10, 95) : 0\n    }\n  }\n}];"
      },
      "id": "analyze-website",
      "name": "Analyze Website",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 500]
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json;\nconst signals = item.signals || {};\nconst wa = item.websiteAnalysis || {};\nconst enrichment = item.enrichment || {};\nconst config = item.config || {};\n\n// ===== AFTER-HOURS SIGNAL =====\nlet afterHoursScore = 0;\nlet afterHoursDetails = [];\n\nif (!item.scrapeSuccess) {\n  afterHoursScore = 45;\n  afterHoursDetails.push('Site protected');\n} else {\n  if (!wa.has24x7) { afterHoursScore += 25; afterHoursDetails.push('No 24/7'); }\n  if (!wa.hasWeekendHours) { afterHoursScore += 15; afterHoursDetails.push('No weekends'); }\n  if (!wa.hasChatWidget) { afterHoursScore += 25; afterHoursDetails.push('No chat'); }\n  if (!wa.hasBookingTool) { afterHoursScore += 15; afterHoursDetails.push('No booking'); }\n}\n\nafterHoursScore = Math.min(afterHoursScore, 100);\nconst afterHoursDetected = afterHoursScore > 35;\n\n// ===== INBOUND RISK SIGNAL =====\nlet inboundScore = 0;\nlet inboundDetails = [];\n\nif (!item.scrapeSuccess) {\n  inboundScore = 40;\n} else {\n  if (!wa.hasPhone) { inboundScore += 30; inboundDetails.push('No phone'); }\n  if (!wa.hasContactForm) { inboundScore += 20; inboundDetails.push('No form'); }\n  if (wa.contactMethodCount <= 1) { inboundScore += 25; inboundDetails.push('Limited contact'); }\n  if (!wa.hasChatWidget) { inboundScore += 10; inboundDetails.push('No instant response'); }\n}\n\ninboundScore = Math.min(inboundScore, 100);\nconst inboundDetected = inboundScore > 40;\nconst riskLevel = inboundScore >= 70 ? 'high' : inboundScore >= 50 ? 'medium' : 'low';\n\n// ===== TECH STACK SIGNAL =====\nconst ts = item.techStack || {};\nconst techDetected = ts.detected || [];\nlet techScore = 0;\n\nconst premiumTech = ['hubspot', 'salesforce', 'marketo', 'intercom'];\nlet premiumCount = 0;\n\nfor (const tech of techDetected) {\n  if (premiumTech.includes(tech)) { premiumCount++; techScore += 20; }\n  else techScore += 5;\n}\n\ntechScore = Math.min(techScore, 95);\nconst techSignalDetected = techScore > 30 && techDetected.length > 2;\n\n// ===== FINAL SIGNALS OBJECT =====\nconst finalSignals = {\n  googleAds: signals.googleAds,\n  hiring: signals.hiring,\n  afterHoursCoverage: {\n    detected: afterHoursDetected,\n    score: afterHoursScore,\n    confidence: item.scrapeSuccess ? 80 : 40,\n    details: afterHoursDetails.join('; ') || 'Good coverage'\n  },\n  inboundRisk: {\n    detected: inboundDetected,\n    score: inboundScore,\n    confidence: item.scrapeSuccess ? 80 : 40,\n    riskLevel,\n    details: inboundDetails.join('; ') || 'Good setup'\n  },\n  techStack: {\n    detected: techSignalDetected,\n    score: techScore,\n    confidence: ts.confidence || 0,\n    tools: techDetected,\n    premiumToolCount: premiumCount,\n    details: premiumCount > 0 ? `Uses ${premiumCount} enterprise tools` : 'Basic stack'\n  }\n};\n\n// ===== CALCULATE TOTAL SCORE =====\nconst weights = { googleAds: 0.30, afterHoursCoverage: 0.25, inboundRisk: 0.20, hiring: 0.15, techStack: 0.10 };\n\nlet totalScore = 0;\nlet detectedSignals = [];\n\nfor (const [key, weight] of Object.entries(weights)) {\n  const signal = finalSignals[key];\n  if (signal?.detected) {\n    detectedSignals.push(key);\n    totalScore += Math.round((signal.score || 0) * weight * (signal.confidence || 50) / 100);\n  }\n}\n\n// Bonuses\nif (detectedSignals.length >= 2) totalScore += 10;\nif (detectedSignals.length >= 3) totalScore += 10;\nif (detectedSignals.includes('googleAds') && detectedSignals.includes('afterHoursCoverage')) totalScore += 12;\n\ntotalScore = Math.min(Math.round(totalScore), 100);\n\n// Ready state\nlet readyState = 'cold';\nif (totalScore >= 65 && detectedSignals.length >= 2) readyState = 'hot';\nelse if (totalScore >= 50) readyState = 'warm';\nelse if (totalScore >= 30) readyState = 'nurture';\n\n// Why Now\nlet whyNowParts = [];\nif (finalSignals.googleAds?.detected) whyNowParts.push(`Active Ads (${finalSignals.googleAds.adCount})`);\nif (afterHoursDetected) whyNowParts.push('After-hours gap');\nif (inboundDetected && riskLevel === 'high') whyNowParts.push('High lead loss risk');\nif (finalSignals.hiring?.detected) whyNowParts.push(`Hiring ${finalSignals.hiring.roles?.slice(0,2).join(', ') || ''}`);\nif (premiumCount > 0) whyNowParts.push('Sophisticated buyer');\n\n// Build signal array for frontend\nconst signalArray = [];\n\nif (finalSignals.googleAds?.detected) {\n  signalArray.push({\n    id: 'googlePaidTraffic',\n    label: 'Google Paid Traffic Active',\n    detected: true,\n    value: finalSignals.googleAds.details,\n    confidence: finalSignals.googleAds.confidence,\n    score: finalSignals.googleAds.score\n  });\n}\n\nif (afterHoursDetected) {\n  signalArray.push({\n    id: 'afterHoursCoverage',\n    label: 'After Hours Coverage Gap',\n    detected: true,\n    value: finalSignals.afterHoursCoverage.details,\n    confidence: finalSignals.afterHoursCoverage.confidence,\n    score: afterHoursScore\n  });\n}\n\nif (inboundDetected) {\n  signalArray.push({\n    id: 'inboundResponseRisk',\n    label: 'Inbound Response Risk',\n    detected: true,\n    value: finalSignals.inboundRisk.details,\n    confidence: finalSignals.inboundRisk.confidence,\n    score: inboundScore\n  });\n}\n\nif (finalSignals.hiring?.detected) {\n  signalArray.push({\n    id: 'hiringSignal',\n    label: 'Active Hiring',\n    detected: true,\n    value: finalSignals.hiring.details,\n    confidence: finalSignals.hiring.confidence,\n    score: finalSignals.hiring.score\n  });\n}\n\nif (techSignalDetected) {\n  signalArray.push({\n    id: 'techStackSignal',\n    label: 'Sophisticated Tech Stack',\n    detected: true,\n    value: finalSignals.techStack.details,\n    confidence: finalSignals.techStack.confidence,\n    score: techScore\n  });\n}\n\nreturn [{\n  json: {\n    domain: item.domain,\n    companyName: item.companyName,\n    score: totalScore,\n    signals: signalArray,\n    signalCount: signalArray.length,\n    whyNow: whyNowParts.length > 0 ? whyNowParts.join(' + ') : 'Limited signals',\n    readyState,\n    confidence: { level: totalScore >= 60 ? 'high' : totalScore >= 40 ? 'medium' : 'low' },\n    enrichment: {\n      linkedIn: enrichment.linkedIn || {},\n      employeeRange: enrichment.linkedIn?.employeeRange,\n      techStack: techDetected,\n      hiringRoles: finalSignals.hiring?.roles || [],\n      hiringPlatforms: finalSignals.hiring?.platforms || []\n    },\n    websiteAnalysis: {\n      chatWidget: wa.chatWidget,\n      hasChatWidget: wa.hasChatWidget || false,\n      bookingTool: wa.bookingTool,\n      hasBookingTool: wa.hasBookingTool || false,\n      hasContactForm: wa.hasContactForm || false,\n      hasPhone: wa.hasPhone || false,\n      has24x7: wa.has24x7 || false\n    },\n    debug: { detectedSignals, scrapeSuccess: item.scrapeSuccess }\n  }\n}];"
      },
      "id": "final-score",
      "name": "Calculate Final Score",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 500]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [1500, 500]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              { "name": "Content-Type", "value": "application/json" },
              { "name": "Access-Control-Allow-Origin", "value": "*" }
            ]
          }
        }
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1700, 500]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [[{ "node": "Normalize Inputs", "type": "main", "index": 0 }]]
    },
    "Normalize Inputs": {
      "main": [[{ "node": "Loop Domains", "type": "main", "index": 0 }]]
    },
    "Loop Domains": {
      "main": [
        [{ "node": "Serper All-In-One", "type": "main", "index": 0 }],
        [{ "node": "Aggregate Results", "type": "main", "index": 0 }]
      ]
    },
    "Serper All-In-One": {
      "main": [[{ "node": "Scrape Website", "type": "main", "index": 0 }]]
    },
    "Scrape Website": {
      "main": [[{ "node": "Analyze Website", "type": "main", "index": 0 }]]
    },
    "Analyze Website": {
      "main": [[{ "node": "Calculate Final Score", "type": "main", "index": 0 }]]
    },
    "Calculate Final Score": {
      "main": [[{ "node": "Loop Domains", "type": "main", "index": 0 }]]
    },
    "Aggregate Results": {
      "main": [[{ "node": "Respond to Webhook", "type": "main", "index": 0 }]]
    }
  },
  "settings": { "executionOrder": "v1" },
  "staticData": null,
  "tags": [{ "name": "SAI Scraper" }, { "name": "Serper" }, { "name": "v2" }]
}
